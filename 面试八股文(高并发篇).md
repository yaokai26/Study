## 1.Synchronized和lock的区别
### 从功能角度来看，两者都是java中用来解决线程安全的工具
### 从特性来看
 * Synchronized是关键字，Lock是JUC包中的接口，这个接口有很多的实现，其中就包括ReentrantLock可重入锁
 * Synchronized通过修饰方法或者修饰代码块这两种粒度，修饰在代码块上可以通过Synchronized加锁对象的生命周期来控制锁的作用范围，如果锁的对象是静态对象或者类对象，那么这个锁就是全局锁，
  如果锁对象是普通实例，那么锁的范围就取决于对象的生命周期，Lock锁的粒度是通过它提供的lock()和unlock()方法决定的，包裹在这两个方法之间的代码能够保证线程安全，而锁的作用域取决于Lock实例的生命周期
 * Lock比Synchronized的灵活性更高，它可以决定什么时候加锁，什么时候释放锁，只需要调用lock()和unlock()就行，同时lock还提供了非阻塞的竞争锁方法tryLock().Synchronized由于是关键字，无法实现非阻塞竞争
   锁的方法，而且Synchronized锁的释放是被动的，只有当同步代码块执行完成或者代码出现异常才会释放。
 * Lock提供了公平锁和非公平锁的机制，公平锁指线程竞争锁资源时，如果已经有其他线程正在排队等待，那么当前竞争锁资源的线程无法插队，非公平锁就是无论是否有线程在排队，都会去竞争。Synchronized只提供了非公平锁
### 从性能看，Sychronized和lock差异不大，Synchronized引入了偏向锁、轻量级锁、重量级锁以及锁升级的方式来优化性能，Lock则用到了自旋锁的方式来实现性能优化

## 2.线程池如何知道一个线程的任务已经执行完成
* 线程池提供了一个isTerminated()方法，可以判断线程池的运行状态，一旦线程池的运行状态是Terminated，就意味着线程池中的所有任务已经执行完了
* 在线程池中有一个submit()方法，他提供了一个Future的返回值，通过Future.get()来获得任务的执行结果，在线程池中的任务没有执行完成之前，这个方法会一直阻塞，直到任务结束。所以通过future.get()方法正常返回，也就意味着任务完成
* 可以引入CountDownLatch计数器，并且计数器为1，当线程池代码块后面调用await()方法阻塞主线程，然后当传入到线程池中的任务执行完后，调用countDown()方法表示任务执行结束，最后计数器归零，唤醒阻塞在await()方法的线程

## 3.谈谈对AQS的理解
AQS是AbstractQueuedSynchronizer的简称,是并发编程中比较核心的组件.
AQS是多线程同步器,他是J.U.C包中多个组件的底层实现,如Lock,CountDownLatch,Semaphore等都用到了AQS,本质上来说AQS提供了两种锁机制,一种是排他锁,一种是共享锁.
排他锁就是存在多线程同时竞争同一共享资源,同一时刻只允许一个线程访问共享资源,Lock中的ReentrantLock重入锁就用到了AQS的排他锁.
共享锁就是同一时刻允许多个线程同事获得锁资源,比如CountDownLatch和Semaphore都是用到AQS的共享锁功能
