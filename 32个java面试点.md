### 1.进程和线程的区别？
    进程是操作系统进行资源分配调度的最小单位，而线程是程序执行的最小单位；
    进程有自己独立的地址空间，而线程是共享进程中的数据的，使用相同的地址空间；
    
    线程的上下文切换？
    CPU在执行一个线程的时候转去运行另一个线程，切换的过程中，CPU会保存上一个线程的状态，以便下次再切换回这个线程可以再次
    加载这个状态,这里会记录程序计数器、CPU寄存器等数据。

### 2.TCP连接的三次握手和断连的四次挥手
    三次握手
    1.主机A和主机B进行通信,由主机A向主机B发送一个SYN同步序列号,请求建立连接,告诉你我要和你通信,你要用哪个序列号作为起始数据段回应我
    2.主机B收到主机A的请求后,发送一个带有应答ACK和同步SYN标志位的数据段响应给主机A,告诉你我收到了你的请求,可以传输了,你要用哪个序列
    号作为起始数据段来回应我
    3.主机A收到主机B的数据段后,发送一个确认应答,告诉你我收到回复了,现在要开始传输数据了.

    四次挥手
    1.主机A完成数据传输后,发送一个FIN报文给主机B
    2.主机B收到主机A发送的FIN报文,对其作出响应,确认这个方向的连接要关闭,将ACK置为1
    3.此时主机A没有数据传输,但是主机B可能还有数据传输,发送完毕之后才会发送FIN报文给主机A,将FIN置为1
    4.主机A收到主机B的断连请求,对其作出响应,确认这一方向也要关闭,等待2MSL后关闭.双向连接关闭结束.
    
    为什么连接要3次,断开要4次?
    这是由于TCP的半关闭导致的,因为TCP的连接是全双工,两个方向都能传输数据,所以每个方向都要单独关闭.

### 3.完整的HTTP请求?
    1.对网址进行DNS域名解析,得到对应的IP
    2.根据IP找到对应的服务器,进行TCP三次握手
    3.发送HTTP请求
    4.服务器响应HTTP请求后返回html
    5.浏览器解析html代码,请求html代码中的资源
    6.浏览器对页面进行渲染呈现给客户

### 4.堆的结构
    JVM主要包含3个系统:类加载系统+运行时数据区系统+执行引擎系统
    运行时数据区系统分为:堆+虚拟机栈+方法区+本地方法栈+程序计数器
    堆分为:年轻代+老年代+永久代(1.8后改为metaspace)
    
    堆主要存放对象实例
    虚拟机栈主要存放局部变量，基本类型
    本地方法栈主要存放本地方法
    方法区主要存放类的信息，静态方法，常量
    程序计数器主要存放程序运行的行号，内存地址
    唯一一个不会报内存溢出的空间是程序计数器。
    
    
    年轻代(复制算法)中为什么Eden区和survivor区是8:1:1?
    因为复制算法用来担保的内存为9:1,当存活的对象大于内存空间的10%需要年老代来进行分配担保.

### 5.==和equals的区别
    1.基本数据类型使用==号是直接比较的值,引用类型使用==比较的是对象的地址
    2.equals如果没有被重写的话,是比较的对象的地址,如果重写了例如String/Date的话比较的是对象的内容(注意equals不能用于基本数据类型)

### 6.判断一个对象是否是可回收(垃圾收集算法)?
    1.引用计数算法:每个对象都有一个引用计数器,被引用就+1,完成引用就-1,不被引用就为0,就可以被回收
    优点:执行效率高,程序受影响较小
    缺点:无法检测循环引用问题,导致内存泄漏
    2.可达性分析:通过判断对象的引用链来决定对象是否可回收,从GC ROOTS作为起点向下搜索,搜索走过的路径称为引用链,当一个对象到GC ROOTS
    没有任何引用链相连,则证明该对象是可以被回收的.

### 7.垃圾回收算法?
    1.复制算法
    将内存分为大小相等的两个区域,每次只使用一部分进行内存分配,当内存使用完后,触发GC,将存活的对象直接复制到另一块空闲的内存中,然后
    清除当前使用的内存块,转到另一块内存进行使用.
    优点：简单，高效
    缺点:浪费内存
    2.标记清除算法
    首先标记出可以回收的对象,然后统一清理可以回收的对象内存.
    缺点：首先标记和清除步骤效率都不高，其次会产生内存碎片
    3.标记整理算法
    在标记清楚算法的第二步进行一个内存整理,将存活的对象进行向一端移动,达到消除内存碎片问题.
    4.分代收集算法
    将虚拟机分为年轻代.老年代.持久代,年轻代使用复制算法,年老代使用标记整理算法.
    
### 8.spring AOP的底层实现
    1.JDK动态代理,动态字节码生成class文件.而且生成的代理类继承了Proxy类,所以通过JDK动态代理的只能是接口(java只能单继承)
    jdk动态代理的含义作用是在运行时动态的生成代理对象,实现对原始对象的增强和扩展
    2.cglib动态代理,通过继承的方式来对类进行代理
    
### 9.强引用.软引用.弱引用.虚引用
    1.强引用:大部分引用都是强引用,内存不足时,即使抛出OOM也不会强制回收强引用对象
    2.软引用:如果内存足够就不会回收,如果内存不足则会回收
    3.弱引用:只具有弱引用的对象具有更短暂的生命周期,GC不管内存是否充足都会回收
    4.虚引用:必须和ReferenceQueue联合使用,用来跟踪对象被垃圾回收的活动.当垃圾回收时,如果发现一个对象持有虚引用,会把这个
    虚引用加入到引用队列中,这样程序就可以根据引用队列是否加入了虚引用,来判断引用的对象是否将要被回收.

### 10.ThreadLocal学习
    1.Synchronized锁是通过线程等待，牺牲时间来实现线程安全解决冲突，而ThreadLocal是通过每个线程单独一份存储空间，牺牲
    空间来解决冲突，ThreadLocal具有线程隔离效果，只有在线程内才能获取到对应的值。
    2.ThreadLocal内部有一个ThreadLocalMap,用于存储每一个线程的变量，key为ThreadLocal线程对象,value为对应线程的变量。
    3.InheritableThreadLocal 子线程可以获取父线程中的数据(子线程创建时,会把父线程中的数据复制一份到子线程中)
    4.TransmittableThreadLocal (能够访问外部线程数据的问题)

### 11.数据库优化
    1.索引是数据库优化成本最低，见效最快的一种方案。
    * 索引一般建立在需要查询的字段上，如果有多个查询条件关键字，可以建立组合索引，例如where,group by后面的字段上
    * 区分度比较高的，离散程度比较高的，例如性别就不建议建立索引
    * 不要在条件=的左边使用函数，不走索引
    2.sql优化
    * 使用join代替子查询
    * 使用union代替临时表
    * 使用外键
    * 使用事务(安全)
    3.数据库引擎
    Myisam是对事务要求不高，以查询和添加为主，Myisam的效率会更高
    innodb是对事务要求高，数据都是重要数据
    innodb支持事务，Myisam不支持事务
    innodb支持外键，Myisam不支持外键
    innodb是行锁，Myisam是表锁
    innodb不支持全文索引,Myisam支持全文索引
    4.分库分表分区
    分库：根据业务逻辑分库，查询库和增删库
    分表：对一些大表进行分表，可以根据查询条件进行分表，例如时间
    分区：相应规则的数据放到一起，只要设定好分区规则
    5.预处理缓存
    6.读写分离

### 12.死锁的条件
     1.互斥：一个资源只能被一个进程占用，其他进程申请使用要等到该资源释放
     2.占有并等待：一个进程至少占有一个资源，并在等待其他资源，而该资源被其他进程占有
     3.不可抢占：资源不可以被抢占，只能等待资源被资源释放
     4.循环等待：多个线程等待其他线程占有的资源，形成闭环。
