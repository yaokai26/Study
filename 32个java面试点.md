### 1.进程和线程的区别？
    进程是操作系统进行资源分配调度的最小单位，而进程是程序执行的最小单位；
    进程有自己独立的地址空间，而线程是共享进程中的数据的，使用相同的地址空间；
    
    线程的上下文切换？
    CPU在执行一个线程的时候转去运行另一个线程，切换的过程中，CPU会保存上一个线程的状态，以便下次再切换回这个线程可以再次
    加载这个状态,这里会记录程序计数器、CPU寄存器等数据。

### 2.TCP连接的三次握手和断连的四次挥手
    三次握手
    1.主机A和主机B进行通信,由主机A向主机B发送一个SYN同步序列号,请求建立连接,告诉你我要和你通信,你要用哪个序列号作为起始数据段回应我
    2.主机B收到主机A的请求后,发送一个带有应答ACK和同步SYN标志位的数据段响应给主机A,告诉你我收到了你的请求,可以传输了,你要用哪个序列
    号作为起始数据段来回应我
    3.主机A收到主机B的数据段后,发送一个确认应答,告诉你我收到回复了,现在要开始传输数据了.

    四次挥手
    1.主机A完成数据传输后,发送一个FIN报文给主机B
    2.主机B收到主机A发送的FIN报文,对其作出响应,确认这个方向的连接要关闭,将ACK置为1
    3.此时主机A没有数据传输,但是主机B可能还有数据传输,发送完毕之后才会发送FIN报文给主机A,将FIN置为1
    4.主机A收到主机B的断连请求,对其作出响应,确认这一方向也要关闭,等待2MSL后关闭.双向连接关闭结束.
    
    为什么连接要3次,断开要4次?
    这是由于TCP的半关闭导致的,因为TCP的连接是全双工,两个方向都能传输数据,所以每个方向都要单独关闭.

### 3.完整的HTTP请求?
    1.对网址进行DNS域名解析,得到对应的IP
    2.根据IP找到对应的服务器,进行TCP三次握手
    3.发送HTTP请求
    4.服务器响应HTTP请求后返回html
    5.浏览器解析html代码,请求html代码中的资源
    6.浏览器对页面进行渲染呈现给客户

### 4.堆的结构
    JVM主要包含3个系统:类加载系统+运行时数据区系统+执行引擎系统
    运行时数据区系统分为:堆+虚拟机栈+方法区+本地方法栈+程序计数器
    堆分为:年轻代+老年代+永久代(1.8后改为metaspace)
    
    年轻代(复制算法)中为什么Eden区和survivor区是8:1:1?
    因为复制算法用来担保的内存为9:1,当存活的对象大于内存空间的10%需要年老代来进行分配担保.

### 5.==和equals的区别
    1.基本数据类型使用==号是直接比较的值,引用类型使用==比较的是对象的地址
    2.equals如果没有被重写的话,是比较的对象的地址,如果重写了例如String/Date的话比较的是对象的内容(注意equals不能用于基本数据类型)

### 6.判断一个对象是否是可回收(垃圾收集算法)?
    1.引用计数算法:每个对象都有一个引用计数器,被引用就+1,完成引用就-1,不被引用就为0,就可以被回收
    优点:执行效率高,程序受影响较小
    缺点:无法检测循环引用问题,导致内存泄漏
    2.可达性分析:通过判断对象的引用链来决定对象是否可回收,从GC ROOTS作为起点向下搜索,搜索走过的路径称为引用链,当一个对象到GC ROOTS
    没有任何引用链相连,则证明该对象是可以被回收的.

### 7.垃圾回收算法?
    1.复制算法
    将内存分为大小相等的两个区域,每次只使用一部分进行内存分配,当内存使用完后,触发GC,将存活的对象直接复制到另一块空闲的内存中,然后
    清除当前使用的内存块,转到另一块内存进行使用.
    优点：简单，高效
    缺点:浪费内存
    2.标记清除算法
    首先标记出可以回收的对象,然后统一清理可以回收的对象内存.
    缺点：首先标记和清除步骤效率都不高，其次会产生内存碎片
    3.标记整理算法
    在标记清楚算法的第二步进行一个内存整理,将存活的对象进行向一端移动,达到消除内存碎片问题.
    4.分代收集算法
    将虚拟机分为年轻代.老年代.持久代,年轻代使用复制算法,年老代使用标记整理算法.
    
### 8.spring AOP的底层实现
    1.JDK动态代理,动态字节码生成class文件.而且生成的代理类继承了Proxy类,所以通过JDK动态代理的只能是接口(java只能单继承)
    2.cglib动态代理,通过继承的方式来对类进行代理
    
### 9.强引用.软引用.弱引用.虚引用
    1.强引用:大部分引用都是强引用,内存不足时,即使抛出OOM也不会强制回收强引用对象
    2.软引用:如果内存足够就不会回收,如果内存不足则会回收
    3.弱引用:只具有弱引用的对象具有更短暂的生命周期,GC不管内存是否充足都会回收
    4.虚引用:必须和ReferenceQueue联合使用,用来跟踪对象被垃圾回收的活动.当垃圾回收时,如果发现一个对象持有虚引用,会把这个
    虚引用加入到引用队列中,这样程序就可以根据引用队列是否加入了虚引用,来判断引用的对象是否将要被回收.
