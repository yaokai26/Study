### 1.面向对象6大原则
* 单一职责原则：一个类应该仅有一个引起它变化的原因，也就是一个类尽量只实现一个功能;
* 开放封闭原则: 程序中的对象应该对于扩展是开放的，对于修改是封闭的，当软件需要变化时，应尽可能通过扩展的方式，
而不是修改已有的代码实现。也就是创建抽象类来隔离以后发生的同类变化。
* 里氏替换原则: 子类型必须能够替换掉他们的基类型，只要父类出现的地方，替换为子类也不会出现任何错误
* 依赖倒置原则: 抽象不依赖于细节，细节依赖于抽象。实现类依赖于接口类，接口类不依赖于实现类。
* 接口隔离原则: 单一职责的必然结果，客户端不应该依赖于他不需要的接口。目的是解耦，易于重构更改。
* 良性依赖原则: 一个对象应该对其他对象有最少的了解。一个类对自己需要耦合或调用的类知道越少越好。

### 2.线程
* sleep是使当前线程进入停滞状态，所以在sleep期间肯定不会执行
* yield是使当前线程进入就绪状态，所以yield的线程有可能马上又被执行。yield的线程会释放时间片，让给其他优先级的线程。
可以设置线程优先级 setPriority(Max_Priority)
* obj.wait()必须在synchronized(obj){}语句块内  

### 3.索引
页page-内存读取磁盘的最小单位,4k
* 为什么不用二叉树作索引？二叉树不是平衡的，而且如果深度太深，只有一个树分支的话，检索效率太低。
* 为什么不用红黑树作索引？红黑树有右旋左旋，消耗资源，而且如果深度较深，还是没有解决效率问题。
* 为什么不用Hash作索引？Hash不支持范围查询，存在Hash碰撞问题，查询效率极低，不支持排序。
* 为什么不用BTree作索引？BTree每个节点都存储key和data,而且叶子节点为null，不包含任何节点信息；
B+Tree叶子节点就包含了所有的关键字信息和指针,每个叶子节点指向下一个节点,形成一个链表
* B+Tree的优点：1.磁盘读写代价更低：因为B+Tree叶子节点包含所有关键字信息，内部节点不存储指向关键字的指针，因此内部节点
更小，存储的关键字就更多，IO读写的次数就降低了。\
  2.查询效率更加稳定：因为B+Tree只有叶子节点存储关键字信息，任何关键字查询必须从跟节点到叶子节点，所有关键字
的查询路径长度相同，查询效率更加稳定。             

非聚集索引(MyISAM索引),数据库文件和索引文件不在一起。聚集索引(InnoDB索引),数据库文件和索引文件存放在一起。 
