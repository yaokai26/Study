## 1.主从数据库延迟的问题
#### 主要原因：数据库在业务上读写压力太大，CPU计算负荷大，网卡负荷大，硬盘随机IO高
#### 次要原因：读写binlog带来的性能影响，网络传输延迟
#### 解决方案
 *  业务的持久层采用分库架构，mysql服务能力水平扩展，分散压力
 *  单库读写分离，一主多从，主写从读，分散压力
 *  服务在业务和DB之间加入memcache或者redis，降低读的压力
 *  不同业务的mysql放在不同的物理机，降低压力
 *  使用比主库更好的硬件设备，mysql压力小了，延迟就小了

## 2.哪些场景不适用索引
 * 查询很少使用到的列，某列中包含的数据比较少
 * 数据类型是TEXT,BLOB,BIT等数据类型的字段
 * 当数据表中的修改数据的频率大于查询的频率

## 3.mysql何时索引失效
 * 在索引上做运算,比如函数
 * 在组合索引上,没有根据最左匹配原则,没有从索引的最左列开始顺序检索
 * 当索引存在隐式转化,比如索引列是字符串,但是sql查询没有使用引号
 * 当索引列使用不等于号,not查询
 * 使用like  %放在最左边
 * 使用or的时候,or语句前后没有同时使用索引,那么索引也会失效

## 4.数据库误操作，如何执行数据恢复
看你数据库是否开启binlog，然后用mysql自带的mysqlbinlog工具找到最近误操作的节点的binlog，重放到临时数据库里，然后选择误删的数据节点恢复一下

## 5.Mysql的性能优化
### 1.硬件及操作系统层面优化
从硬件层面来说,影响Mysql性能的因素有CPU,可用内存大小,磁盘读写速度,网络带宽,这一部分大部分由DBA或者运维工程师去完成
### 2.架构设计层面的优化
Mysql是磁盘IO非常频繁的关系数据库,优化有几点:
* 搭建mysql主从集群,单个节点容易发生故障宕机
* 读写分离设计
* 分库分表的设计,分库可以降低单个服务器节点的IO压力,分表可以降低单表的数据量,提示查询效率
* 针对热点数据,引入分布式数据库,如Redis,MongoDB等,缓解Mysql的压力
### 3.Mysql配置优化
通过my.cnf配置文件,比如最大连接数等,还有是否开启binlog,缓存池bufferpool的默认大小配置等
### 4.SQL优化
* 慢SQL的定位和排查,可以通过慢查询日志和慢查询日志分析工具得到有问题的sql
* 执行计划分析,针对慢SQL,可以用explain关键字来查看当前sql的执行计划,可以重点关注type,key,rows filer等字段
* SQL的优化具体:1.查询基于索引; 2.避免在索引上使用函数或者运算,会导致索引失效; 3.where字句like %号尽量放在右边; 4.尽可能使用sql语句用到的索引完成排序,避免使用文件排序;5.查询有效的列信息即可,少用*代替; 6.永远用小表驱动大表

## 6.说一下Mysql的事务隔离级别
  多个事务竞争可能会出现脏读,不可重复读,幻读现象,因此有四种隔离级别:
  * 读未提交,这种情况下会出现脏读,幻读,不可重复读
  * 读已提交,这种级别下可能会出现不可重复读和幻读
  * 可重复读,这种隔离级别下可能会产生幻读
  * 串行化,不会产生安全问题

## 7.索引有哪些缺点以及有哪些索引
  索引的优点:提高查询的效率,减少查询时间,保证数据的唯一性(唯一索引)
  索引的缺点:创建和维护索引消耗时间,索引需要额外占用物理空间,对创建了索引的表进行数据的增删改会同步维护索引,造成性能影响
  索引的类型:
        1) 主键索引,不能为null,一个表只能有一个
        2) 唯一索引,允许为null,允许多个
        3) 普通索引,允许为null
        4) 全文索引
        5) 覆盖索引,查询列要被所建的索引覆盖,不必读取数据行
        6) 组合索引,多列值组成一个索引

## 8.Mybatis的缓存机制
  1) 一级缓存,就是sqlSession级别的缓存,也叫本地缓存,为了避免每次查询都去查数据库,mybatis把查询出来的数据保存到sqlSession中,后续sql如果命中就直接从本地缓存读取.SqlSession中持有一个executor,每一个executor都有一个local cache本地缓存.
  2) 二级缓存,开启二级缓存之后,会被多个sqlSession共享,因为他的流程是先查二级缓存,再查一级缓存,最后再查数据库.二级缓存相对一级缓存来说,实现了sqlSession的共享.使用CachingExecutor装饰了executor,所以进入一级缓存,会先通过CachingExecutor进行二级缓存查询
  
## 9.说一下你对Redis的理解
### redis是基于Key-value的nosql数据库,目前市面上大多数公司都用Redis来实现分布式缓存,提高检索效率,他这么快主要原因有
* 他是基于内存存储,在进行IO操作时,可以达到10W QPS
* 他提供了丰富的数据存储结构,如String,List(用做简单的消息队列,lrange做分页功能),Hash,Set(去重功能),sorted set(做排行榜功能)等
* Redis底层采用单线程实现数据的IO,所以数据算法层面不需要考虑并发安全性
* Redis也可以持久化,避免因为服务器故障导致数据丢失的问题,除此之外,Redis还可以实现分布式锁,分布式队列,排行榜,查找附近的人等功能

## 10.Mysql中innoDB和MyISAM的区别
* 数据存储的方式：MyISAM是将数据和索引分开存储的，innoDB是存储在一起的
* 对事务的支持：MyISAM不支持事务，innoDB支持事务
* 对锁的支持: MyISAM支持表锁,innoDB根据不同情况,支持表锁,行锁,临时锁,间隙锁
* MyISAM不支持外键,innoDB支持外键

## 11.redis缓存问题
#### 缓存雪崩：redis中多个Key失效，又遇到高并发，导致大量的请求直接打到数据库，导致数据库服务宕机。 解决方案：会给redis中的key设置不同的生命周期或者使用分布式锁来解决
原因:1.缓存中间件宕机,做高可用集群来避免; 2.大部分key都设置了相同的过期时间,在过期时间上设置一个随机值
#### 缓存击穿：大量请求过来请求数据库都没有的数据，导致数据库服务宕机。解决方案：给redis一个key值value为null。
1)对于热点数据可以不设置过期时间,或者访问时对过期时间进行续期
2)使用分布式锁,防止数据库被压垮,获得锁的从数据库查询数据,写到缓存里,没有获取到锁的只需要等待和重试
3)对于访问量过高的缓存数据,可以设计多级缓存
4)可以用布隆过滤器,先到布隆过滤器里面去查询,不存在,那意味着这个key在数据库里也不存在
#### 缓存预热
系统上线后,将相关的缓存数据直接加载到缓存系统,避免用户请求的时候直接访问数据库
#### 缓存更新
缓存淘汰策略
* 定期去清理过期的缓存
* 当有用户请求过来再判断这个请求用到的缓存是否过期,过期的话就去数据库获取新数据并缓存

## 12.如何保证mysql和redis的数据一致性
不管是先更新数据库再更新缓存,还是先更新缓存再更新数据库,因为不满足原子性,都会出现数据不一致.
两种方案:
 * 先更新数据库,再更新缓存,失败的请求写入MQ中,让MQ去异步重试,确保成功
 * 先更新数据库,再更新缓存,通过Cannl组件,监控Mysql的binlog日志,把更新后的数据同步到Redis里

## 13.Redis过期策略和内存淘汰机制
过期策略是:Redis是采用定期删除+惰性删除策略\
淘汰机制有:
 * Random 随机移除某个key
 * TTL 在设置了过期时间的key中,移除更早过期时间
 * LRU 移除很长时间没有使用的key.链表结构,新数据插入到头部,命中数据的话把数据放到头部,链表满的话就把链表尾部的数据丢弃
 * LFU 移除使用频率很低的key.双向链表,保存访问频率和访问频率相同的所有元素(用使用频率和上次访问时间来标记数据的热度,如果有读写,就增加访问频率,如果一段时间没有读写,就减少访问频率)

## 14.redis主从复制的原理
redis主从复制包含全量复制和增量复制.
* 全量复制发生在从节点初始化阶段,从节点主动向主节点发起一个同步请求,主节点收到请求后会生成一份当前数据的快照发送给从节点,从节点接收数据完成复制.
* 增量复制发生在主节点数据发生变化时,主节点会把变化的数据同步给从节点,增量复制是通过维护Offset这个复制偏移量来实现的

## 15.Redis为什么这么快
* 纯内存操作
* 单线程操作,避免了频繁的上下文切换
* 采用了非阻塞的I/O多路复用机制:单线程,通过跟踪每个I/O的状态,来管理多个I/O流

## 16.什么是MVCC
多版本并发控制MVCC,是一种用来解决读写冲突的无锁并发控制,也就是为事务分配单向增长的时间戳,为每个修改增加版本,版本与事务时间戳关联,读操作只读事务开启前的数据库快照.避免了脏读和不可重复读.
MVCC主要依赖记录中的3个隐式字段,undo log,read view来实现

## Mysql分库分表
### 垂直拆分
按照业务对表进行分类,分布到不同的数据库,将压力分散到不同的数据库上.例如订单库,用户库,支付金额库\
优点: 

      1.拆分后,业务清晰,规则明确
      2.系统之间整合或者扩展比较容易
      3.数据维护简单
缺点:

      1.部分业务表无法join,只能通过接口解决,增加了业务复杂度
      2.事务处理复杂
### 水平拆分
把同一个表拆分到不同的数据库中,将一张表的某个字段的某种规则来分散到多个库中.
优点: 

      1.不存在单库大数据.高并发的瓶颈
      2.对应用透明,应用端改造少
      3.join可以使用
      4.提高了稳定性和负载能力
缺点:

      1.拆分规则难以抽象
      2.分片事务一致性难以解决
      3.数据多次扩展维护难
      4.跨库join性能差
