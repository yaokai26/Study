## 1.主从数据库延迟的问题
#### 主要原因：数据库在业务上读写压力太大，CPU计算负荷大，网卡负荷大，硬盘随机IO高
#### 次要原因：读写binlog带来的性能影响，网络传输延迟
#### 解决方案
 *  业务的持久层采用分库架构，mysql服务能力水平扩展，分散压力
 *  单库读写分离，一主多从，主写从读，分散压力
 *  服务在业务和DB之间加入memcache或者redis，降低读的压力
 *  不同业务的mysql放在不同的物理机，降低压力
 *  使用比主库更好的硬件设备，mysql压力小了，延迟就小了

## 2.哪些场景不适用索引
 * 查询很少使用到的列，某列中包含的数据比较少
 * 数据类型是TEXT,BLOB,BIT等数据类型的字段
 * 当数据表中的修改数据的频率大于查询的频率

## 3.mysql内部函数
concat,trim,replace,substring,curdate,curtime,selectif,ifnull,selectifnull

## 4.数据库误操作，如何执行数据恢复
看你数据库是否开启binlog，然后用mysql自带的mysqlbinlog工具找到最近误操作的节点的binlog，重放到临时数据库里，然后选择误删的数据节点恢复一下

## 5.Mysql的性能优化
### 1.硬件及操作系统层面优化
从硬件层面来说,影响Mysql性能的因素有CPU,可用内存大小,磁盘读写速度,网络带宽,这一部分大部分由DBA或者运维工程师去完成
### 2.架构设计层面的优化
Mysql是磁盘IO非常频繁的关系数据库,优化有几点:
* 搭建mysql主从集群,单个节点容易发生故障宕机
* 读写分离设计
* 分库分表的设计,分库可以降低单个服务器节点的IO压力,分表可以降低单表的数据量,提示查询效率
* 针对热点数据,引入分布式数据库,如Redis,MongoDB等,缓解Mysql的压力
### 3.Mysql配置优化
通过my.cnf配置文件,比如最大连接数等,还有是否开启binlog,缓存池bufferpool的默认大小配置等
### 4.SQL优化
* 慢SQL的定位和排查,可以通过慢查询日志和慢查询日志分析工具得到有问题的sql
* 执行计划分析,针对慢SQL,可以用explain关键字来查看当前sql的执行计划,可以重点关注type,key,rows filer等字段
* SQL的优化具体:1.查询基于索引; 2.避免在索引上使用函数或者运算,会导致索引失效; 3.where字句like %号尽量放在右边; 4.尽可能使用sql语句用到的索引完成排序,避免使用文件排序;5.查询有效的列信息即可,少用*代替; 6.永远用小表驱动大表

## 6.说一下Mysql的事务隔离级别
  多个事务竞争可能会出现脏读,不可重复读,幻读现象,因此有四种隔离级别:
  * 读未提交,这种情况下会出现脏读,幻读,不可重复读
  * 读已提交,这种级别下可能会出现不可重复读和幻读
  * 可重复读,这种隔离级别下可能会产生幻读
  * 串行化,不会产生安全问题

## 7.索引有哪些缺点以及有哪些索引
  索引的优点:提高查询的效率,减少查询时间,保证数据的唯一性(唯一索引)
  索引的缺点:创建和维护索引消耗时间,索引需要额外占用物理空间,对创建了索引的表进行数据的增删改会同步维护索引,造成性能影响
  索引的类型:
        1) 主键索引,不能为null,一个表只能有一个
        2) 唯一索引,允许为null,允许多个
        3) 普通索引,允许为null
        4) 全文索引
        5) 覆盖索引,查询列要被所建的索引覆盖,不必读取数据行
        6) 组合索引,多列值组成一个索引
  
## 8.说一下你对Redis的理解
### redis是基于Key-value的nosql数据库,目前市面上大多数公司都用Redis来实现分布式缓存,提高检索效率,他这么快主要原因有
* 他是基于内存存储,在进行IO操作时,可以达到10W QPS
* 他提供了丰富的数据存储结构,如String,List,Hash,Set,ZSet等
* Redis底层采用单线程实现数据的IO,所以数据算法层面不需要考虑并发安全性
* Redis也可以持久化,避免因为服务器故障导致数据丢失的问题,除此之外,Redis还可以实现分布式锁,分布式队列,排行榜,查找附近的人等功能

## 9.redis缓存问题
#### 缓存雪崩：redis中多个Key失效，又遇到高并发，导致大量的请求直接打到数据库，导致数据库服务宕机。 解决方案：会给redis中的key设置不同的生命周期或者使用分布式锁来解决
#### 缓存击穿：大量请求过来请求数据库都没有的数据，导致数据库服务宕机。解决方案：给redis一个key值value为null，给个失效时间。

## 10.如何保证mysql和redis的数据一致性
不管是先更新数据库再更新缓存,还是先更新缓存再更新数据库,因为不满足原子性,都会出现数据不一致.
两种方案:
 * 先更新数据库,再更新缓存,失败的请求写入MQ中,让MQ去异步重试,确保成功
 * 先更新数据库,再更新缓存,通过Cannl组件,监控Mysql的binlog日志,把更新后的数据同步到Redis里

## 11.Redis内存淘汰算法
 * Random 随机移除某个key
 * TTL 在设置了过期时间的key中,移除更早过期时间
 * LRU 移除最近很少使用的key.随机取出key按照时间排序,访问的时间间隔最大的key就移除
 * LFU 移除最近很少使用的key.双向链表,保存访问频率和访问频率相同的所有元素(用使用频率和上次访问时间来标记数据的热度,如果有读写,就增加访问频率,如果一段时间没有读写,就减少访问频率)
   
