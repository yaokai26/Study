## 一面
### 1.红黑树
含义：红黑树是一种含有红黑节点并且能自平衡的二叉查找树，它必须满足以下性质：

    1.结点要么是黑色要么是红色
    2.根节点是黑色
    3.每个叶子节点是黑色（nil）
    4.每个红色节点的两个子结点必定是黑色
    5.任一一个结点到每个叶子节点的路径都包含相同数量的黑结点
 
 红黑树能自平衡，靠的是：左旋，右旋，变色
    
    1.左旋：以某个节点为旋转点，其右节点变为父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变
    2.右旋：以某个节点为旋转点，其左节点变为父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变
    3.变色：节点由黑变红，或者由红变黑
 
### 2.volatile原理(内存屏障)
1.含义：如果一个线程对一个volatile的变量进行更新，那么其他线程可以立马看到这个更新，这就是所谓的线程可见性。
    
    结合内存模型来讲。计算机运行程序时，每条指令都是在CPU中执行的，在过程中一定涉及到数据的读写，数据是存储在主内存中，
    这时有一个问题，读写主内存中的数据没有CPU执行指令快，如果任何交互都要和主内存打交道则会大大影响效率，所以有了高速
    缓存(理解是运行内存)，CPU高速缓存是某个CPU独有，只与该CPU运行的线程有关。
    CPU高速缓存解决了效率问题，也出现了数据不一致问题。运行程序时，会将主内存中的数据复制一份到CPU高速缓存中，在运算
    时也不与主内存打交道，直接从高速缓存中读写数据，运行结束后才将数据更新到主内存中。

2.java内存模型
    
    * 原子性：即一个操作或者多个操作，要么全部执行并且执行过程不会被任何因素打断，要么都不执行。
    （java认为基本数据类型的赋值操作具有原子性，32位JDK环境下，对64位数据的读写不是原子性操作，如long,double）
    要在多线程环境下保证原子性，可以通过锁、synchronized来确保。
    * 可见性：当一个变量被volatile修饰后，表示本地内存无效，当一个线程修改共享变量后，它会被立刻更新到
    主内存中，其他线程读取共享变量时，她会直接从主内存中读取。
    synchronized和锁都能保证可见性。
    * 有序性：程序执行的顺序按照代码的先后顺序执行。volatile保证可见性，但是不保证原子性。volatile禁止指令重排序。

3.总结：volatile相对于synchronized更轻量级一些，在某些场合可以替换它，但是又不能完全替代他，要使用volatile，需要满足：\
    * 1.对变量的写操作不依赖当前值\
    * 2.该变量没有包含在具有其他变量的不变式中\
    * 3.volatile经常用于两个两场景：状态标记两，double check
    
### 3.垃圾回收
1.java堆的内存结构：新生代、年老代、持久代(jdk1.8中已经移除),其中新生代包含一个伊甸区和两个一样的幸存区。

    java垃圾回收的过程：
    Eden伊甸区：首先当一个实例被创建，他会存储在伊甸区。
    Survivor幸存区：年轻代GC(Minor GC)周期的一部分，存活的对象会从伊甸区复制到S0区，类似地，垃圾回收器会扫描S0 然后将存活的
    实例复制转移到S1区。
    老年代：老年代是实例生命周期的最后阶段，Major GC扫描老年代的垃圾回收过程，如果实例不再被引用，那么他们会被标记回收。
    
2.垃圾回收是一个守护线程。\
垃圾收集器：
        
        1.串行垃圾回收器：使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，只适合简单的命令行程序
        2.并行垃圾回收器：使用多线程进行垃圾回收，相同的是，他也会冻结所有应用程序线程
        3.并发标记扫描垃圾回收器：使用多线程扫描堆内存，标记需要清理的实例并清理已经被标记过的实例。并发标记扫描垃圾回收器只会
     在两种情况持有应用程序的所有线程：标记的引用对象在老年代;在进行垃圾回收的时候，堆内存中的数据被并发的改变。
        相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量，但是需要分配更多的CPU。
        4.G1垃圾回收器：适用于堆内存比较大的情况，G1会将堆内存分割成不同的区域，并且并发地对其进行垃圾回收，而且在回收内存之后
     对剩余的堆内存空间进行压缩。

### 4.索引及结构
索引的类型：
    
      联合索引：单列索引、复合(联合)索引
      覆盖索引：如果查询的列，通过索引项的信息可直接返回，则称该索引为查询SQL的覆盖索引
      唯一索引和非唯一索引
      B树索引、位图索引、反向键索引等...
      
创建索引的几大原则：
       
      1.列的离散型：性别那种数据单一的关键字不做索引
      2.最左匹配原则：(like %a 百分号出现在左边,即全匹配，从左往右一个一个字符进行对比，不走索引)
      对于索引中的关键字进行对比的时候，一定是从左往右依此对比，且不可跳过
      3.最少空间原则：
      当关键字的空间越小，每个节点存储的关键字数量就越多，每次加载进内存的关键字越多，检索效率就越高
结论：
      
      1.索引列的数据长度根据业务的情况能少则少
      2.索引不是越多越好
      3.where子句中的 like 9%,like %9%,like %9 三种方式都用不到索引，后两种方式是违反最左匹配原则，索引无效
      第一种9%是不确定的，决定于列的离散型，如果离散程度较差，查询优化器觉得走索引查询性能差，还不如全表
      4.where子句的not in 不走索引
      5.多用指定查询，少用select * from,这里没用到覆盖索引，用了覆盖索引，可以不需要进入数据区，就能直接返回
      6.查询条件有函数，索引会失效，这和列的离散型有关
 
 B树和B+树的比较：
    
      B树每一个节点都存储了key和data，并且叶子节点指针为null，叶子节点不包含任何关键字信息。
      B+树所有的叶子节点就包含了所有关键字的信息，以及指向这些关键字的指针，每个叶子节点指向下一个叶子节点，
      1、B+树的磁盘读写代价更低，其内部节点不存储指向关键字信息的指针，所以内部节点更小，能够存储的关键字就更多，
      IO读写次数就降低了。
      2、B+树的查询效率更加稳定
      由于B+树只有叶子节点存储关键字索引，任何关键字的查询必须从根节点到叶子节点，所有关键字的查询路径长度相同，查询效率更稳定

### 5.数据库学习
1.数据库事务：事务是对数据库中一系列操作进行回滚或提交操作，主要用来保证数据的一致性和完整性。\
2.事务的四大特性(ACID)

    A 原子性：事务包含的所有操作要么都完成要么都失败回滚。
    C.一致性：事务开始前和结束后，数据库的完整性不变。A转账给B，结束后A和B的总量不变。
    I.隔离性：事务与事务之间，相互隔离，互不干扰。
    D.持久性：事务一旦提交，对数据库的改变是永久性的。
    
3.事务的并发
    
    1、脏读：事务A读取了事务B修改的数据，然后事务B回滚操作，事务A读取到的数据是脏数据。
    2、不可重复读：事务A多次读取同一数据，在事务A读取期间，事务B更改了更改并提交，导致事务A读取到数据前后结果不一致
    3、幻读：事务A对表中的某项数据做了从1更新到2的操作，这时事务B又对这个表插入了一行数据，数值为1，导致事务A再查刚才的数据
    发现和没有修改一样，就像产生了幻觉。
    不可重复读和幻读差不多，但是幻读解决了不可重复读，保证了同一个事务里，查询的都是事务开始时的状态。但是不可重复读侧重的是
    修改，幻读侧重的是插入增加和删除。解决不可重复读要锁住满足条件的行，解决幻读需要锁表。
    
4.事务的隔离级别

    1、读未提交(Read UnCommitted)：事务A可以读取到事务B修改但是还未提交的数据---脏读
    2、不可重复读(Read Committed)：事务A多次读取同一数据，事务B在此期间对数据进行了修改并提交，导致事务A读取到的数据前后不一致。
    3、可重复读(Repeatable Read)：在同一个事务里，select读取的数据都是事务开始时间的状态，因此select读到的数据都是一样的，但是会有幻读。
    4、串行化(Serializable)：最高的隔离级别，不会出现任何异常，就好像事务一个个按照顺序执行。Serializable是在每个读的数据行加锁。
注意：MySQL的默认事务隔离级别是repeatable Read（可重复读），Oracle有两种事务隔离级别(Read Committed不可重复读和Serializable 串行化)
串行化时，读写操作会锁表，未提交读时，写数据会锁住当前行，可重复读时，写数据会锁住表。

5.搜索引擎
    
    MyISAM：强调的是性能，每次查询具有原子性，但是不支持事务。只支持表级锁。
    InnoDB：支持事务和行级锁，是InnoDB的最大特色，行锁大大提高了用户并发操作的性能，但是InnoDB的行锁，只在where后面是主键是有效的，不然锁全表。

### 6.Redis学习
1.Redis单线程：单线程指的是网络请求模块使用了一个线程(所以不需要考虑并发性),即一个线程处理所有网络请求，其他模块仍使用多线程。\
2.Redis为什么能够快速执行

    1.绝大部分请求是纯粹的内存操作
    2.采用单线程，避免不必要的上下文切换和竞争条件
    3.非阻塞I0-IO多路复用
3.Redis内部实现\
  内部实现采用epoll,采用epoll+自己实现的事件框架,epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，不在IO上浪费时间。\
4.Redis线程安全\
  redis采用线程封闭的思想，把任务封闭在一个线程内，避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，还需要锁，而且是分布式锁。\
5.Redis好处
   
    1.速度快，因为都是内存操作，数据存在内存中
    2.数据类型丰富，支持string,hash,list,set,sorted set
    3.支持事务，操作都是原子性
    4.丰富的特性：可用于缓存，消息，按KEY设置过期时间，过期后自动删除
    
    Redis和Memcached相比有哪些优势？
    1.memcached都是简单字符串，redis类型更加丰富
    2.redis速度比memcached快很多
    3.redis可持久化数据
    4.redis支持数据备份
    5.value大小，redis最大可以1GB,memcached最大1MB
6.Redis持久化：RDB和AOF(RDB恢复数据比AOF更快，AOF比RDB保存的数据集更加完整)

### 7.多线程
1.线程的创建方式
    
    1、继承Thread,new MyThread(){ run();}.start();
    2、实现Runnable接口，new Thread(new Runnable(){ run();}).start();
    3、实现Callable接口，MyCallable<Integer> callable = new MyCallable<Integer>(); FutureTask<Integer> futureTask = new FutureTask<>(callable); new Thread(futureTask).start();   futureTask.get可以获取Callable产生的结果/可以看做是带有回调的Runnable.
    Thread不建议使用，因为Java是单继承的，继承了Thread就不能继承其他类；Runnable比Thread更灵活，不受单继承的限制。
    4.线程池 Executors可以创建4中线程池
    * newFixedThreadPool 定长线程池
    * newScheduledThreadPool 定长线程池，处理周期和定时任务的执行
    * newCachedThreadPool 缓存线程池
    * newSingleThreadExecutor 单线程化的线程池
    阿里的java开发手册不建议使用Executors去创建,而是通过ThreadPoolExecutor方式创建,因为Executors提供的线程有弊端,
    FixedThreadPool和SingleThreadPool阻塞队列长度是Integer.Max_value,请求增加会内存溢出,
    ScheduledThreadPool和CachedThreadPool中最大线程数是Integer.Max_value,请求增加会导致创建大量的线程,造成性能下降,甚至宕机.
    Thread实现了Runnable接口，Callable封装成FutureTask,FutureTask实现RunnableFuture,RunnableFuture继承Runnable接口，
    所以本质三种方式都是Runnable实现。  
2.线程池ThreadPool

    好处：
    1.减少了线程创建和销毁的次数，节省了不少开销，可重复利用，提高性能
    2.可以根据系统的承受能力，调整线程池中工作线程的数目
    3.提供定时执行、定期执行、单线程、并发数控制等
    4.Executor其实是执行线程的工具，真正的线程池接口是ExecutorService
    ExecutorService esc = Executor.newFixedThreadPool(2);
    Future<String> task = esc.submit(callable);
    String s = task.get();
    
3.线程的状态

    1、创建new 
    2、就绪runnable:调用Start方法，等待CPU调度 
    3、运行running:执行run方法
    4、阻塞blocked：sleep.wait.join没有获取到锁都会阻塞
    5、死亡terminated
    sleep和join都可以被中断，不同的是join内部调用了wait，会释放锁，而sleep不会释放锁，sleep在thread中，wait在object中。
    
4.线程安全的定义\
  线程是系统运算调度的最小单位，说线程安全，其实是针对多线程环境下说的，如果代码在多线程环境下同时运行，结果和单线程运行
的结果是一样的，而且其他变量的值和预期也是一样的，就是线程安全的。
  
5.什么是上下文切换？\
   即使是单核CPU也可以支持多线程，因为CPU通过给每个线程分配时间片，时间片是分配给各个线程的时间，因为时间很短，
所以CPU通过不断切换线程执行，让我们感觉多个线程是同时执行的。切换的过程中，CPU会保存上一个任务的状态，以便下次切
换回这个任务时，可以再次加载这个任务状态。从任务保存到再加载的过程就是一次上下文切换。


### 8.Synchronized和ReentrantLock的区别

    可重入锁：指同一个线程可以多次获得同一把锁，synchronzied和ReentrantLock都属于可重入锁
    可中断锁：指线程尝试取锁的过程是否可以相应中断，synchronized是不可中断锁，ReentrantLock提供了中断功能
    公平性锁：指多个线程尝试同时获得一个锁，获得锁的顺序和线程到达的顺序一致
    非公平性锁：指允许插队，竞争
    
    ReentrantLock是自旋锁，通过循环调用CAS操作来实现加锁。他是非公平性锁，这是出于性能考虑，可以将参数设置为true改为公平性锁，默认是非公平性锁。

### 9.SQL优化

    1.在where或者group by后面的字段建立索引。
    2.避免使用select * from，尽量使用具体的字段。因为如果具体的字段正好是联合索引也就是二级索引里的字段，就可以直接返回，无须回表。
    3.避免使用in和not in，全表扫描，in可以用exist代替
    4.模糊查询 %用在左边，全表扫描，最左匹配原则
    5.条件语句中使用函数，索引会失效，全表扫描
    6.避免使用or,全表扫描
    7.避免对Null值进行判断，全表扫描
    8.where 1=1，全表扫描

### 10.类加载器
    
    类加载的过程
    1.加载：查找和导入class文件
    2.验证：验证class文件的正确性
    3.准备：为类分配内存并设置类变量初始值
    4.解析：虚拟机将常量池内的符号引用转换为直接引用
    5.初始化：初始化静态变量，静态代码块
    
    类加载器
    1.启动类加载器
    2.扩展类加载器
    3.应用类加载器
    类加载器的双亲委派模型：如果一个类收到了类加载请求，它首先不会自己尝试去加载，而是把这个请求委派给父类加载器去完成，只有当父类加载器
    反馈无法完成这个加载请求时，才会自己尝试去加载。

    如何打破双亲委派机制呢?
    1.集成ClassLoader类,自己重写loadClass方法
    2.使用线程上下文加载器,可以用java.lang.Thread类的setContextClassLoader()方法设置当前使用的类加载器类型

### 11.HashMap

    1.扩容是一个非常消耗性能的过程，所以在使用时，给一个默认的初始值，避免频繁的扩容
    2.负载因子可以修改，也可以大于1，但是不建议修改，链表长度大，遍历会增大开销
    3.HashMap是线程不安全的，要使用ConcurentHashMap或者Collections.synchronized方法
    4.Jdk1.8在hashmap中加入了红黑树，使得hashmap的查找从O(n)变为了O(logn)

hashMap中put方法的流程,如下图:\
![附图15](https://github.com/yaokai26/Images/blob/master/15.png)

