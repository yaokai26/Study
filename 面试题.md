## 一面
### 1.红黑树
含义：红黑树是一种含有红黑节点并且能自平衡的二叉查找树，它必须满足一下性质：

    1.结点要么是黑色要么是红色
    2.根节点是黑色
    3.每个叶子节点是黑色（nil）
    4.每个红色节点的两个子结点必定是黑色
    5.任一一个结点到每个叶子节点的路径都包含相同数量的黑结点
 
 红黑树能自平衡，靠的是：左旋，右旋，变色
    
    1.左旋：以某个节点为旋转点，其右节点变为父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变
    2.右旋：以某个节点为旋转点，其左节点变为父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变
    3.变色：节点由黑变红，或者由红变黑
 
### 2.volatile原理(内存屏障)
1.含义：如果一个线程对一个volatile的变量进行更新，那么其他线程可以立马看到这个更新，这就是所谓的线程可见性。
    
    结合内存模型来讲。计算机运行程序时，每条指令都是在CPU中执行的，在过程中一定涉及到数据的读写，数据是存储在主内存中，
    这时有一个问题，读写主内存中的数据没有CPU执行指令快，如果任何交互都要和主内存打交道则会大大影响效率，所以有了高速
    缓存(理解是运行内存)，CPU高速缓存是某个CPU独有，只与该CPU运行的线程有关。
    CPU高速缓存解决了效率问题，也出现了数据不一致问题。运行程序时，会将主内存中的数据复制一份到CPU高速缓存中，在运算
    时也不与主内存打交道，直接从高速缓存中读写数据，运行结束后才将数据更新到主内存中。

2.java内存模型
    
    * 原子性：即一个操作或者多个操作，要么全部执行并且执行过程不会被任何因素打断，要么都不执行。
    （java认为基本数据类型的赋值操作具有原子性，32位JDK环境下，对64位数据的读写不是原子性操作，如long,double）
    要在多线程环境下保证原子性，可以通过锁、synchronized来确保。
    * 可见性：当一个变量被volatile修饰后，表示本地内存无效，当一个线程修改共享变量后，它会被立刻更新到
    主内存中，其他线程读取共享变量时，她会直接从主内存中读取。
    synchronized和锁都能保证可见性。
    * 有序性：程序执行的顺序按照代码的先后顺序执行。volatile保证可见性，但是不保证原子性。volatile禁止指令重排序。

3.总结：volatile相对于synchronized更轻量级一些，在某些场合可以替换它，但是又不能完全替代他，要使用volatile，需要满足：\
    * 1.对变量的写操作不依赖当前值\
    * 2.该变量没有包含在具有其他变量的不变式中\
    * 3.volatile经常用于两个两场景：状态标记两，double check
    
### 3.垃圾回收
1.java堆的内存结构：新生代、年老代、持久代(jdk1.8中已经移除),其中新生代包含一个伊甸区和两个一样的幸存区。

    java垃圾回收的过程：
    Eden伊甸区：首先当一个实例被创建，他会存储在伊甸区。
    Survivor幸存区：年轻代GC(Minor GC)周期的一部分，存活的对象会从伊甸区复制到S0区，类似地，垃圾回收器会扫描S0 然后将存活的
    实例复制转移到S1区。
    老年代：老年代是实例生命周期的最后阶段，Major GC扫描老年代的垃圾回收过程，如果实例不再被引用，那么他们会被标记回收。
    
2.垃圾回收是一个守护线程。\
垃圾收集器：
        
        1.串行垃圾回收器：使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，只适合简单的命令行程序
        2.并行垃圾回收器：使用多线程进行垃圾回收，相同的是，他也会冻结所有应用程序线程
        3.并发标记扫描垃圾回收器：使用多线程扫描堆内存，标记需要清理的实例并清理已经被标记过的实例。并发标记扫描垃圾回收器只会
     在两种情况持有应用程序的所有线程：标记的引用对象在老年代;在进行垃圾回收的时候，堆内存中的数据被并发的改变。
        相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量，但是需要分配更多的CPU。
        4.G1垃圾回收器：适用于堆内存比较大的情况，G1会将堆内存分割成不同的区域，并且并发地对其进行垃圾回收，而且在回收内存之后
     对剩余的对内存空间进行压缩。

### 4.索引及结构
索引的类型：
    
      联合索引：单列索引、复合(联合)索引
      覆盖索引：如果查询的列，通过索引项的信息可直接返回，则称该索引为查询SQL的覆盖索引
      唯一索引和非唯一索引
      B树索引、位图索引、反向键索引等...
      
创建索引的几大原则：
       
      1.列的离散型：性别那种数据单一的关键字不做索引
      2.最左匹配原则：(like %a 百分号出现在左边,即全匹配，从左往右一个一个字符进行对比，不走索引)
      对于索引中的关键字进行对比的时候，一定是从左往右以此对比，且不可跳过
      3.最少空间原则：
      当关键字的空间越小，每个节点存储的关键字数量就越多，每次加载进内存的关键字越多，检索效率就越高
结论：
      
      1.索引列的数据长度根据业务的情况能少则少
      2.索引不是越多越好
      3.where子句中的 like 9%,like %9%,like %9 三种方式都用不到索引，后两种方式是违反最左匹配原则，索引无效
      第一种9%是不确定的，决定于列的离散型，如果离散程度较差，查询优化器觉得走索引查询性能差，还不如全表
      4.where子句的not in 不走索引
      5.多用指定查询，少用select * from,这里没用到覆盖索引，用了覆盖索引，可以不需要进入数据区，就能直接返回
      6.查询条件有函数，索引会失效，这和列的离散型有关
 
 B树和B+树的比较：
    
      B树每一个节点都存储了key和data，并且叶子节点指针为null，叶子节点不包含任何关键字信息。
      B+树所有的叶子节点就包含了所有关键字的信息，以及指向这些关键字的指针，每个叶子节点指向下一个叶子节点，
      1、B+树的磁盘读写代价更低，其内部节点不存储指向关键字信息的指针，所以内部节点更小，能够存储的关键字就更多，
      IO读写次数就降低了。
      2、B+树的查询效率更加稳定
      由于B+树只有叶子节点存储关键字索引，任何关键字的查询必须从根节点到叶子节点，所有关键字的查询路径长度相同，查询效率更稳定

### 5.数据库学习
1.数据库事务：事务是对数据库中一系列操作进行回滚或提交操作，主要用来保证数据的一致性和完整性。\
2.事务的四大特性(ACID)

    A 原子性：事务包含的所有操作要么都完成要么都失败回滚。
    C.一致性：事务开始前和结束后，数据库的完整性不变。A转账给B，结束后A和B的总量不变。
    I.隔离性：事务与事务之间，相互隔离，互不干扰。
    D.持久性：事务一旦提交，对数据库的改变是永久性的。
    
3.事务的并发
    
    1、脏读：事务A读取了事务B修改的数据，然后事务B回滚操作，事务A读取到的数据是脏数据。
    2、不可重复读：事务A多次读取同一数据，在事务A读取期间，事务B更改了更改并提交，导致事务A读取到数据前后结果不一致
    3、幻读：事务A对表中的某项数据做了从1更新到2的操作，这时事务B又对这个表插入了一行数据，数值为1，导致事务A再查刚才的数据
    发现和没有修改一样，就像产生了幻觉。
    不可重复读和幻读差不多，但是幻读解决了不可重复读，保证了同一个事务里，查询的都是事务开始时的状态。但是不可重复读侧重的是
    修改，幻读侧重的是插入增加和删除。解决不可重复读要锁住满足条件的行，解决幻读需要锁表。
    
4.事务的隔离级别

    1、读未提交(Read UnCommitted)：事务A可以读取到事务B修改但是还未提交的数据---脏读
    2、不可重复读(Read Committed)：事务A多次读取同一数据，事务B在此期间对数据进行了修改并提交，导致事务A读取到的数据前后不一致。
    3、可重复读(Repeatable Read)：在同一个事务里，select读取的数据都是事务开始时间的状态，因此select读到的数据都是一样的，但是会有幻读。
    4、串行化(Serializable)：最高的隔离级别，不会出现任何异常，就好像事务一个个按照顺序执行。Serializable是在每个读的数据行加锁。
注意：MySQL的默认事务隔离级别是repeatable Read（可重复读），Oracle有两种事务隔离级别(Read Committed不可重复读和Serializable 串行化)
串行化时，读写操作会锁表，未提交读时，写数据会锁住当前行，可重复读时，写数据会锁住表。

5.搜索引擎
    
    MyISAM：强调的是性能，每次查询具有原子性，但是不支持事务。只支持表级锁。
    InnoDB：支持事务和行级锁，是InnoDB的最大特色，行锁大大提高了用户并发操作的性能，但是InnoDB的行锁，只在where后面是主键是有效的，不然锁全表。

### 6.Redis学习
1.Redis单线程：单线程指的是网络请求模块使用了一个线程(所以不需要考虑并发性),即一个线程处理所有网络请求，其他模块仍使用多线程。\
2.Redis为什么能够快速执行

    1.绝大部分请求是纯粹的内存操作
    2.采用单线程，避免不必要的上下文切换和竞争条件
    3.非阻塞I0-IO多路复用
3.Redis内部实现\
  内部实现采用epoll,采用epoll+自己实现的事件框架,epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，不在IO上浪费时间。、
4.Redis线程安全\
  redis采用线程封闭的思想，把任务封闭在一个线程内，避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，还需要锁，而且是分布式锁。\
5.Redis好处\
   
    1.速度快，因为都是内存操作，数据存在内存中
    2.数据类型丰富，支持string,hash,list,set,sorted set
    3.支持事务，操作都是原子性
    4.丰富的特性：可用于缓存，消息，按KEY设置过期时间，过期后自动删除
    
    Redis和Memcached相比有哪些优势？
    1.memcached都是简单字符串，redis类型更加丰富
    2.redis速度比memcached快很多
    3.redis可持久化数据
    4.redis支持数据备份
    5.value大小，redis最大可以1GB,memcached最大1MB
6.Redis持久化：RDB和AOF(RDB恢复数据比AOF更快，AOF比RDB保存的数据集更加完整)

    

